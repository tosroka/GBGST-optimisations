// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ProcessOutput

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<half4> Result;
//Stores the input image and is set with cs.SetTexture
Texture2D<half4> StylizedImage;
Texture2D<half4> PreviousStylizedImage;
Texture2D<half4> MotionVectors;
Texture2D<half4> NormalMap;
Texture2D<half4> DepthMap;
Texture2D<half4> AmbientOcclusion;
SamplerState PointSampler;
float4 _ZBufferParams;  // This is set by Unity
float4 _ProjectionParams;

float2 _ScreenResolution = (1920, 1080);
float3 _WorldSpaceCameraPos;

float LinearizeDepth(float depth) {

    float _CameraNear = _ProjectionParams.y;  // Camera's near clipping plane distance, set this from your script
    float _CameraFar = _ProjectionParams.z;   // Camera's far clipping plane distance, set this from your script

    // The depth value should be in [0,1] range, if it's not you might need to adjust it.
    float linearDepth = 1.0f / (_ZBufferParams.x * depth + _ZBufferParams.y);

    // Normalize linear depth to [0, 1] range
    float normalizedDepth = (linearDepth - _CameraNear) / (_CameraFar - _CameraNear);

    return normalizedDepth;
}

[numthreads(8, 8, 1)]
void ProcessOutput(uint3 id : SV_DispatchThreadID)
{

    //// Sampling original and stylized frames
    half3 stylizedColor = StylizedImage[id.xy].rgb / 255.0h;
    half3 previousStylizedColor = PreviousStylizedImage[id.xy].rgb;
    half3 currentFrameColor = AmbientOcclusion[id.xy].rgb;
    // stylizedColor = lerp(stylizedColor, currentFrameColor, 0.1h);
    // Sampling motion vectors
    half2 motion = MotionVectors[id.xy].rg;

    // //// Compute the UV for the previous frame based on motion vectors
    half2 previousUV = id.xy - motion; // *half2(8.0h, 8.0h);  // Multiplied by thread size. Adjust as needed.
    half3 motionPreviousStylizedColor = PreviousStylizedImage[previousUV].rgb;

    half motionMagnitude = saturate(length(motion) / 2.0h); // The value "2.0h" here is a normalization factor, adjust it based on the motion vector range in your scene.
      //// Compute the difference. You might want to use a more sophisticated metric.
    half difference = length(stylizedColor - motionPreviousStylizedColor);
    // Normalize the difference
    difference = saturate(difference * 1.0h); // 5.0h is an arbitrary factor, adjust to control sensitivity to color differences.
    half blendFactor = (difference + motionMagnitude) * 0.5h;


    half depth = DepthMap[id.xy].r;  // Assume depth is normalized between 0 and 1
    half depthWeight = lerp(0.0h, 0.2h, depth);  // Adjust the lerp values to your liking
    half depthWeightC = lerp(0.0h, 0.4h, depth);
    half3 normal = NormalMap[id.xy].rgb * 2.0h - 1.0h;  // Re-map normal values from [0,1] to [-1,1]
    half facingRatio = dot(normal, float3(0, 0, 1));  // Assuming camera is oriented along the z-axis
    facingRatio = (facingRatio + 1.0h) * 0.5h;  // Re-map facing ratio to [0,1]
    // stylizedColor = stylizedColor * depthWeight;
    //half3 outputColor = lerp(stylizedColor, previousStylizedColor, blendFactor * depthWeight);
    half combinedWeight = depthWeight * facingRatio;  // Combine both weights
    // half3 outputColor = lerp(stylizedColor, currentFrameColor, depthWeight);
    half normalIntensity = max(dot(normal, half3(0, 0, 1)), 0) + 1.0h; // Adjust normal intensity based on facing direction
    currentFrameColor = currentFrameColor * normalIntensity; // currentFrameColor * normalIntensity;
    half3 stylizedNewColor = lerp(stylizedColor, currentFrameColor, depthWeight);
    half3 outputColor = lerp(stylizedNewColor, motionPreviousStylizedColor, depthWeightC);
    //outputColor = lerp(outputColor, previousStylizedColor, 0.3);

   //  half3 outputColor = lerp(stylizedColor, currentFrameColor, facingRatio);
    outputColor = clamp(outputColor, 0, 1);

    // // Write to the result texture
    Result[id.xy] = half4(outputColor, 1.0h);


}